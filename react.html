<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>    
    <title>Document</title>
</head>
<body>
    <nav class="navbar navbar-expand-lg bg-body-tertiary">
        <div class="container-fluid">
          <a class="navbar-brand" href="./index.html">Home</a>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
              <li class="nav-item">
                <a class="nav-link active" aria-current="page" href="#">Home</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#">Link</a>
              </li>
              <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                  Dropdown
                </a>
                <ul class="dropdown-menu">
                  <li><a class="dropdown-item" href="#">Action</a></li>
                  <li><a class="dropdown-item" href="#">Another action</a></li>
                  <li><hr class="dropdown-divider"></li>
                  <li><a class="dropdown-item" href="#">Something else here</a></li>
                </ul>
              </li>
            </ul>
          </div>
        </div>
      </nav>
      <div class="container my-5">
          <div class="container">
            <div class="accordion accordion-flush my-3" id="accordionFlushReactFundamentals">
                <h3>1. Fundamentals</h3>
              
                <!-- 1. What is React -->
                <div class="accordion-item">
                  <h2 class="accordion-header" id="flush-react-1">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse-react-1" aria-expanded="false" aria-controls="flush-collapse-react-1">
                      1. What is React?
                    </button>
                  </h2>
                  <div id="flush-collapse-react-1" class="accordion-collapse collapse" aria-labelledby="flush-react-1" data-bs-parent="#accordionFlushReactFundamentals">
                    <div class="accordion-body">
                      <ul>
                        <li>JavaScript library for building UI components (developed by Facebook)</li>
                        <li>Declarative, component-based architecture</li>
                        <li>Focuses on the View in MVC</li>
                        <li>Uses Virtual DOM for efficient UI updates</li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 2. Benefits & core principles -->
                <div class="accordion-item">
                  <h2 class="accordion-header" id="flush-react-2">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse-react-2" aria-expanded="false" aria-controls="flush-collapse-react-2">
                      2. Benefits & Core Principles
                    </button>
                  </h2>
                  <div id="flush-collapse-react-2" class="accordion-collapse collapse" aria-labelledby="flush-react-2" data-bs-parent="#accordionFlushReactFundamentals">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Declarative:</strong> Describe UI based on state</li>
                        <li><strong>Component-based:</strong> Reusable building blocks</li>
                        <li><strong>Unidirectional data flow:</strong> Predictable state management</li>
                        <li>Strong ecosystem & community support</li>
                        <li>High performance with Virtual DOM diffing</li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 3. JSX -->
                <div class="accordion-item">
                  <h2 class="accordion-header" id="flush-react-3">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse-react-3" aria-expanded="false" aria-controls="flush-collapse-react-3">
                      3. JSX
                    </button>
                  </h2>
                  <div id="flush-collapse-react-3" class="accordion-collapse collapse" aria-labelledby="flush-react-3" data-bs-parent="#accordionFlushReactFundamentals">
                    <div class="accordion-body">
                      <h6>Syntax & rules</h6>
                      <ul>
                        <li>XML-like syntax for describing UI</li>
                        <li>Must return a single parent element</li>
                        <li>Tags must be closed (<code>&lt;img /&gt;</code>)</li>
                        <li><code>class</code> → <code>className</code>, <code>for</code> → <code>htmlFor</code></li>
                      </ul>
              
                      <h6>Embedding expressions</h6>
                      <pre><code class="language-jsx">
              <h1>{user.name}</h1>
                      </code></pre>
              
                      <h6>Differences from HTML</h6>
                      <ul>
                        <li>Attribute names are camelCase (<code>tabIndex</code>)</li>
                        <li>JS expressions instead of string concatenation</li>
                        <li>No direct HTML event attributes — use camelCase (<code>onClick</code>)</li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 4. Components -->
                <div class="accordion-item">
                  <h2 class="accordion-header" id="flush-react-4">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse-react-4" aria-expanded="false" aria-controls="flush-collapse-react-4">
                      4. Components
                    </button>
                  </h2>
                  <div id="flush-collapse-react-4" class="accordion-collapse collapse" aria-labelledby="flush-react-4" data-bs-parent="#accordionFlushReactFundamentals">
                    <div class="accordion-body">
                      <h6>Functional vs Class components</h6>
                      <ul>
                        <li><strong>Functional:</strong> Simpler, use hooks (<code>useState</code>, <code>useEffect</code>)</li>
                        <li><strong>Class:</strong> Use lifecycle methods (<code>componentDidMount</code>, etc.)</li>
                      </ul>
              
                      <h6>Component composition</h6>
                      <pre><code class="language-jsx">
                        <pre>
                            &lt;Header /&gt;
                            &lt;MainContent /&gt;
                            &lt;Footer /&gt;
                            </pre>                            
                      </code></pre>
              
                      <h6>Props (passing data to components)</h6>
                      <ul>
                        <li>Immutable data passed from parent to child</li>
                      </ul>
                      <pre><code class="language-jsx">
              <Greeting name="John" />
                      </code></pre>
              
                      <h6>Default props & propTypes</h6>
                      <pre><code class="language-jsx">
              Greeting.defaultProps = { name: 'Guest' };
              Greeting.propTypes = { name: PropTypes.string };
                      </code></pre>
                    </div>
                  </div>
                </div>
              
                <!-- 5. State -->
                <div class="accordion-item">
                  <h2 class="accordion-header" id="flush-react-5">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse-react-5" aria-expanded="false" aria-controls="flush-collapse-react-5">
                      5. State
                    </button>
                  </h2>
                  <div id="flush-collapse-react-5" class="accordion-collapse collapse" aria-labelledby="flush-react-5" data-bs-parent="#accordionFlushReactFundamentals">
                    <div class="accordion-body">
                      <h6>useState hook</h6>
                      <pre><code class="language-jsx">
              const [count, setCount] = useState(0);
                      </code></pre>
              
                      <h6>Updating state correctly (immutability)</h6>
                      <ul>
                        <li>Never mutate state directly (<code>state.push()</code>)</li>
                        <li>Use new object/array instead (<code>[...state, newItem]</code>)</li>
                      </ul>
              
                      <h6>State batching</h6>
                      <p>React batches multiple state updates for performance. In React 18+, batching happens in all contexts, not just events.</p>
                    </div>
                  </div>
                </div>
              
                <!-- 6. Rendering -->
                <div class="accordion-item">
                  <h2 class="accordion-header" id="flush-react-6">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse-react-6" aria-expanded="false" aria-controls="flush-collapse-react-6">
                      6. Rendering
                    </button>
                  </h2>
                  <div id="flush-collapse-react-6" class="accordion-collapse collapse" aria-labelledby="flush-react-6" data-bs-parent="#accordionFlushReactFundamentals">
                    <div class="accordion-body">
                      <h6>Conditional rendering</h6>
                      <pre><code class="language-jsx">
              {isLoggedIn ? <Dashboard /> : <Login />}
                      </code></pre>
              
                      <h6>Lists & keys</h6>
                      <pre><code class="language-jsx">
              {items.map(item => <li key={item.id}>{item.name}</li>)}
                      </code></pre>
              
                      <h6>Controlled vs uncontrolled components</h6>
                      <p><strong>Controlled:</strong> Form data managed by state</p>
                      <pre><code class="language-jsx">
                        <pre>
                            &lt;input value={name} onChange={e => setName(e.target.value)} /&gt;
                        </pre>
                      </code></pre>
                      <p><strong>Uncontrolled:</strong> Access data via ref instead of state</p>
                    </div>
                  </div>
                </div>
              
            </div>
            <div class="accordion accordion-flush my-3" id="accordionFlushExampleHooks">
                <h3>2. Hooks (Functional Component Features)</h3>
              
                <!-- 1. useState -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-usestate" aria-expanded="false" aria-controls="flush-usestate">
                      1. useState — managing state
                    </button>
                  </h2>
                  <div id="flush-usestate" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleHooks">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Declares state variables in functional components.</li>
                        <li><strong>Syntax:</strong>
                          <pre><code>const [count, setCount] = useState(0);
              setCount(prev =&gt; prev + 1);</code></pre>
                        </li>
                        <li><strong>Notes:</strong> Updates are asynchronous and should be immutable.</li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 2. useEffect -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-useeffect" aria-expanded="false" aria-controls="flush-useeffect">
                      2. useEffect — side effects, cleanup, dependency arrays
                    </button>
                  </h2>
                  <div id="flush-useeffect" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleHooks">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Handles side effects (data fetching, subscriptions, DOM manipulation). Runs after render.</li>
                        <li><strong>Syntax:</strong>
                          <pre><code>useEffect(() =&gt; {
                fetchData();
                return () =&gt; cleanup(); // optional
              }, [dependency]);</code></pre>
                        </li>
                        <li><strong>Dependency array:</strong>
                          <ul>
                            <li><code>[]</code> → run once on mount</li>
                            <li><code>[var]</code> → run when <code>var</code> changes</li>
                            <li>Omit → run after every render</li>
                          </ul>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 3. useRef -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-useref" aria-expanded="false" aria-controls="flush-useref">
                      3. useRef — accessing DOM elements, persisting values
                    </button>
                  </h2>
                  <div id="flush-useref" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleHooks">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Stores a mutable value that doesn’t trigger re-renders. Access DOM nodes directly.</li>
                        <li><strong>Syntax:</strong>
                          <pre><code>const inputRef = useRef();
              &lt;input ref={inputRef} /&gt;
              inputRef.current.focus();</code></pre>
                        </li>
                        <li><strong>Notes:</strong> Persists values across renders without causing updates.</li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 4. useContext -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-usecontext" aria-expanded="false" aria-controls="flush-usecontext">
                      4. useContext — global state without prop drilling
                    </button>
                  </h2>
                  <div id="flush-usecontext" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleHooks">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Access shared data from a Context without passing props manually.</li>
                        <li><strong>Syntax:</strong>
                          <pre><code>const value = useContext(MyContext);</code></pre>
                        </li>
                        <li><strong>Notes:</strong> Combine with <code>Context.Provider</code> at a higher level.</li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 5. useReducer -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-usereducer" aria-expanded="false" aria-controls="flush-usereducer">
                      5. useReducer — state management alternative to useState
                    </button>
                  </h2>
                  <div id="flush-usereducer" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleHooks">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Manages complex state logic.</li>
                        <li><strong>Syntax:</strong>
                          <pre><code>const [state, dispatch] = useReducer(reducer, initialState);
              function reducer(state, action) { /* ... */ }
              dispatch({ type: 'INCREMENT' });</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 6. useMemo -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-usememo" aria-expanded="false" aria-controls="flush-usememo">
                      6. useMemo — memoizing expensive calculations
                    </button>
                  </h2>
                  <div id="flush-usememo" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleHooks">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Caches computed values until dependencies change. Prevents unnecessary recalculations.</li>
                        <li><strong>Syntax:</strong>
                          <pre><code>const result = useMemo(() =&gt; heavyCalc(data), [data]);</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 7. useCallback -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-usecallback" aria-expanded="false" aria-controls="flush-usecallback">
                      7. useCallback — memoizing functions
                    </button>
                  </h2>
                  <div id="flush-usecallback" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleHooks">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Returns a memoized callback function. Useful for preventing unnecessary child re-renders.</li>
                        <li><strong>Syntax:</strong>
                          <pre><code>const handleClick = useCallback(() =&gt; doSomething(), [dependency]);</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 8. Custom hooks -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-customhooks" aria-expanded="false" aria-controls="flush-customhooks">
                      8. Custom hooks — creating reusable hook logic
                    </button>
                  </h2>
                  <div id="flush-customhooks" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleHooks">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Functions starting with <code>use</code> that encapsulate hook logic.</li>
                        <li><strong>Example:</strong>
                          <pre><code>function useFetch(url) { /* ... */ }</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 9. Rules of Hooks -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-rulesofhooks" aria-expanded="false" aria-controls="flush-rulesofhooks">
                      9. Rules of Hooks — do’s & don’ts
                    </button>
                  </h2>
                  <div id="flush-rulesofhooks" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleHooks">
                    <div class="accordion-body">
                      <ul>
                        <li>Call hooks at the top level (not inside loops/conditions).</li>
                        <li>Call hooks only in React functions (components or custom hooks).</li>
                        <li>Never call hooks inside regular JS functions or class components.</li>
                      </ul>
                    </div>
                  </div>
                </div>
            </div>
            <div class="accordion accordion-flush my-3" id="accordionFlushExampleRouter">
                <h3>3. React Router (Navigation)</h3>
              
                <!-- 1. BrowserRouter, Routes, Route -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-browserrouter" aria-expanded="false" aria-controls="flush-browserrouter">
                      1. BrowserRouter, Routes, Route
                    </button>
                  </h2>
                  <div id="flush-browserrouter" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleRouter">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>BrowserRouter:</strong> Wraps the app and enables routing using HTML5 history API.</li>
                        <li><strong>Routes:</strong> Groups <code>Route</code> elements, ensures only one matching route renders.</li>
                        <li><strong>Route:</strong> Maps a path to a component.</li>
                        <li><strong>Example:</strong>
                          <pre><code>import { BrowserRouter, Routes, Route } from "react-router-dom";
              
              &lt;BrowserRouter&gt;
                &lt;Routes&gt;
                  &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                  &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
                &lt;/Routes&gt;
              &lt;/BrowserRouter&gt;</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 2. Link vs NavLink -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-linknavlink" aria-expanded="false" aria-controls="flush-linknavlink">
                      2. Link vs NavLink
                    </button>
                  </h2>
                  <div id="flush-linknavlink" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleRouter">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Link:</strong> Navigation without page reload.</li>
                        <li><strong>NavLink:</strong> Like Link but adds styling for active link.</li>
                        <li><strong>Example:</strong>
                          <pre><code>&lt;Link to="/about"&gt;About&lt;/Link&gt;
              &lt;NavLink to="/about" className={({ isActive }) =&gt; isActive ? 'active' : ''}&gt;About&lt;/NavLink&gt;</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 3. Route parameters (useParams) -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-useparams" aria-expanded="false" aria-controls="flush-useparams">
                      3. Route parameters (useParams)
                    </button>
                  </h2>
                  <div id="flush-useparams" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleRouter">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Define dynamic segments in path with <code>:paramName</code>. Access with <code>useParams()</code>.</li>
                        <li><strong>Example:</strong>
                          <pre><code>&lt;Route path="/users/:id" element={&lt;User /&gt;} /&gt;
              
              function User() {
                const { id } = useParams();
                return &lt;h1&gt;User ID: {id}&lt;/h1&gt;;
              }</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 4. Query params & useSearchParams -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-usesearchparams" aria-expanded="false" aria-controls="flush-usesearchparams">
                      4. Query params & useSearchParams
                    </button>
                  </h2>
                  <div id="flush-usesearchparams" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleRouter">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Manage query strings.</li>
                        <li><strong>Example:</strong>
                          <pre><code>import { useSearchParams } from "react-router-dom";
              
              function Products() {
                const [searchParams, setSearchParams] = useSearchParams();
                const category = searchParams.get('category');
                return &lt;div&gt;Category: {category}&lt;/div&gt;;
              }</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 5. Nested routes -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-nestedroutes" aria-expanded="false" aria-controls="flush-nestedroutes">
                      5. Nested routes
                    </button>
                  </h2>
                  <div id="flush-nestedroutes" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleRouter">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Routes inside routes; <code>Outlet</code> renders child route content.</li>
                        <li><strong>Example:</strong>
                          <pre><code>&lt;Route path="/dashboard" element={&lt;Dashboard /&gt;}&gt;
                &lt;Route path="stats" element={&lt;Stats /&gt;} /&gt;
              &lt;/Route&gt;
              
              function Dashboard() {
                return &lt;&gt;
                  &lt;h1&gt;Dashboard&lt;/h1&gt;
                  &lt;Outlet /&gt;
                &lt;/&gt;;
              }</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 6. Programmatic navigation (useNavigate) -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-usenavigate" aria-expanded="false" aria-controls="flush-usenavigate">
                      6. Programmatic navigation (useNavigate)
                    </button>
                  </h2>
                  <div id="flush-usenavigate" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleRouter">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Navigate in code instead of using <code>&lt;Link&gt;</code>.</li>
                        <li><strong>Example:</strong>
                          <pre><code>const navigate = useNavigate();
              navigate("/login");</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 7. Protected routes & route guards -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-protectedroutes" aria-expanded="false" aria-controls="flush-protectedroutes">
                      7. Protected routes & route guards
                    </button>
                  </h2>
                  <div id="flush-protectedroutes" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleRouter">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Custom wrapper that checks auth before rendering.</li>
                        <li><strong>Example:</strong>
                          <pre><code>function ProtectedRoute({ children }) {
                const isAuth = useAuth();
                return isAuth ? children : &lt;Navigate to="/login" /&gt;;
              }
              
              &lt;Route path="/dashboard" element={
                &lt;ProtectedRoute&gt;&lt;Dashboard /&gt;&lt;/ProtectedRoute&gt;
              } /&gt;</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
            </div>
            <div class="accordion accordion-flush my-3" id="accordionFlushExampleState">
                <h3>4. State Management</h3>
              
                <!-- 1. Context API (global state) -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-contextapi" aria-expanded="false" aria-controls="flush-contextapi">
                      1. Context API (global state)
                    </button>
                  </h2>
                  <div id="flush-contextapi" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleState">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Built-in React API for sharing state globally without prop drilling.</li>
                        <li><strong>How it works:</strong> Uses <code>createContext()</code> and <code>Context.Provider</code> to pass data down the component tree.</li>
                        <li><strong>Best for:</strong> Small-to-medium apps; not ideal for very complex state.</li>
                        <li><strong>Example:</strong>
                          <pre><code>const ThemeContext = React.createContext();
              
              function App() {
                const [theme, setTheme] = useState("light");
              
                return (
                  &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;
                    &lt;ChildComponent /&gt;
                  &lt;/ThemeContext.Provider&gt;
                );
              }
              
              function ChildComponent() {
                const { theme } = React.useContext(ThemeContext);
                return &lt;div&gt;Theme: {theme}&lt;/div&gt;;
              }</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 2. Redux basics -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-reduxbasics" aria-expanded="false" aria-controls="flush-reduxbasics">
                      2. Redux basics
                    </button>
                  </h2>
                  <div id="flush-reduxbasics" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleState">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Predictable state container for JavaScript apps.</li>
                        <li><strong>Key parts:</strong>
                          <ul>
                            <li><strong>Store:</strong> Holds the entire application state.</li>
                            <li><strong>Actions:</strong> Plain objects that describe what happened (<code>{ type: "ADD_TODO" }</code>).</li>
                            <li><strong>Reducers:</strong> Pure functions returning new state based on current state and action.</li>
                          </ul>
                        </li>
                        <li><strong>Example:</strong>
                          <pre><code>// Action
              const increment = { type: "INCREMENT" };
              
              // Reducer
              function counterReducer(state = 0, action) {
                switch (action.type) {
                  case "INCREMENT":
                    return state + 1;
                  default:
                    return state;
                }
              }
              
              // Store
              import { createStore } from "redux";
              const store = createStore(counterReducer);</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 3. useSelector, useDispatch -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-useselector" aria-expanded="false" aria-controls="flush-useselector">
                      3. useSelector, useDispatch
                    </button>
                  </h2>
                  <div id="flush-useselector" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleState">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>useSelector:</strong> Reads data from the Redux store inside a component.</li>
                        <li><strong>useDispatch:</strong> Sends (dispatches) actions to the Redux store.</li>
                        <li><strong>Example:</strong>
                          <pre><code>import { useSelector, useDispatch } from "react-redux";
              
              function Counter() {
                const count = useSelector(state =&gt; state);
                const dispatch = useDispatch();
              
                return (
                  &lt;&gt;
                    &lt;p&gt;{count}&lt;/p&gt;
                    &lt;button onClick={() =&gt; dispatch({ type: "INCREMENT" })}&gt;+&lt;/button&gt;
                  &lt;/&gt;
                );
              }</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              
                <!-- 4. Redux Toolkit (RTK) -->
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-rtk" aria-expanded="false" aria-controls="flush-rtk">
                      4. Redux Toolkit (RTK)
                    </button>
                  </h2>
                  <div id="flush-rtk" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleState">
                    <div class="accordion-body">
                      <ul>
                        <li><strong>Definition:</strong> Official recommended way to write Redux logic.</li>
                        <li><strong>Features:</strong> <code>createSlice()</code> combines reducers and actions in one place, less boilerplate, supports immutable updates internally.</li>
                        <li><strong>Example:</strong>
                          <pre><code>import { configureStore, createSlice } from "@reduxjs/toolkit";
              
              const counterSlice = createSlice({
                name: "counter",
                initialState: 0,
                reducers: {
                  increment: state =&gt; state + 1,
                },
              });
              
              export const { increment } = counterSlice.actions;
              const store = configureStore({ reducer: counterSlice.reducer });</code></pre>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
            </div>
            <div class="accordion accordion-flush my-3" id="accordionFlushExampleForms">
              <h3>5. Forms &amp; Validation</h3>
            
              <!-- 1. Controlled form inputs -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-controlled-inputs" aria-expanded="false" aria-controls="flush-controlled-inputs">
                    1. Controlled form inputs
                  </button>
                </h2>
                <div id="flush-controlled-inputs" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleForms">
                  <div class="accordion-body">
                    <ul>
                      <li><strong>Definition:</strong> React form inputs where the value is stored in component state.</li>
                      <li><strong>Behavior:</strong> Every keystroke triggers <code>onChange</code> to update state, making React the single source of truth.</li>
                      <li><strong>Advantages:</strong> Allows real-time validation and dynamic behavior.</li>
                      <li><strong>Example:</strong>
                        <pre><code>import { useState } from "react";
            
            function MyForm() {
              const [name, setName] = useState("");
            
              return (
                &lt;form&gt;
                  &lt;input 
                    value={name} 
                    onChange={e =&gt; setName(e.target.value)} 
                    placeholder="Enter name" 
                  /&gt;
                  &lt;p&gt;{name}&lt;/p&gt;
                &lt;/form&gt;
              );
            }</code></pre>
                      </li>
                    </ul>
                  </div>
                </div>
              </div>
            
              <!-- 2. Handling multiple inputs -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-multiple-inputs" aria-expanded="false" aria-controls="flush-multiple-inputs">
                    2. Handling multiple inputs
                  </button>
                </h2>
                <div id="flush-multiple-inputs" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleForms">
                  <div class="accordion-body">
                    <ul>
                      <li><strong>Definition:</strong> Use one state object to store multiple form field values.</li>
                      <li><strong>Technique:</strong> Use the <code>name</code> attribute of inputs to update the correct field dynamically.</li>
                      <li><strong>Example:</strong>
                        <pre><code>function MyForm() {
              const [formData, setFormData] = useState({ username: "", email: "" });
            
              const handleChange = e =&gt; {
                const { name, value } = e.target;
                setFormData(prev =&gt; ({ ...prev, [name]: value }));
              };
            
              return (
                &lt;form&gt;
                  &lt;input name="username" value={formData.username} onChange={handleChange} /&gt;
                  &lt;input name="email" value={formData.email} onChange={handleChange} /&gt;
                &lt;/form&gt;
              );
            }</code></pre>
                      </li>
                    </ul>
                  </div>
                </div>
              </div>
            
              <!-- 3. Form validation -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-form-validation" aria-expanded="false" aria-controls="flush-form-validation">
                    3. Form validation
                  </button>
                </h2>
                <div id="flush-form-validation" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleForms">
                  <div class="accordion-body">
                    <h5>a. Custom validation</h5>
                    <p>Manual checks for field values before submission. Useful for small forms with specific rules.</p>
                    <pre><code>function MyForm() {
              const [email, setEmail] = useState("");
              const [error, setError] = useState("");
            
              const handleSubmit = e =&gt; {
                e.preventDefault();
                if (!email.includes("@")) setError("Invalid email address");
              };
            
              return (
                &lt;form onSubmit={handleSubmit}&gt;
                  &lt;input value={email} onChange={e =&gt; setEmail(e.target.value)} /&gt;
                  {error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;}
                  &lt;button type="submit"&gt;Submit&lt;/button&gt;
                &lt;/form&gt;
              );
            }</code></pre>
            
                    <h5>b. Formik + Yup</h5>
                    <p>Formik manages form state and handles submissions; Yup provides schema-based validation.</p>
                    <pre><code>import { Formik, Form, Field, ErrorMessage } from "formik";
            import * as Yup from "yup";
            
            const schema = Yup.object({
              email: Yup.string().email("Invalid email").required("Required"),
            });
            
            &lt;Formik
              initialValues={{ email: "" }}
              validationSchema={schema}
              onSubmit={values =&gt; console.log(values)}
            &gt;
              &lt;Form&gt;
                &lt;Field name="email" /&gt;
                &lt;ErrorMessage name="email" /&gt;
                &lt;button type="submit"&gt;Submit&lt;/button&gt;
              &lt;/Form&gt;
            &lt;/Formik&gt;</code></pre>
            
                    <h5>c. React Hook Form</h5>
                    <p>Lightweight library using uncontrolled inputs for better performance, with built-in validation.</p>
                    <pre><code>import { useForm } from "react-hook-form";
            
            function MyForm() {
              const { register, handleSubmit, formState: { errors } } = useForm();
            
              const onSubmit = data =&gt; console.log(data);
            
              return (
                &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
                  &lt;input {...register("email", { required: "Email is required" })} /&gt;
                  {errors.email &amp;&amp; &lt;p&gt;{errors.email.message}&lt;/p&gt;}
                  &lt;button type="submit"&gt;Submit&lt;/button&gt;
                &lt;/form&gt;
              );
            }</code></pre>
                  </div>
                </div>
              </div>
            </div>
            <div class="accordion accordion-flush my-3" id="accordionFlushExampleDataFetching">
              <h3>6. Data Fetching</h3>
            
              <!-- 1. Fetch API & Axios -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-fetch-axios" aria-expanded="false" aria-controls="flush-fetch-axios">
                    1. Fetch API &amp; Axios
                  </button>
                </h2>
                <div id="flush-fetch-axios" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleDataFetching">
                  <div class="accordion-body">
                    <ul>
                      <li><strong>Description:</strong> Native Fetch API and Axios (popular HTTP client) are used to make HTTP requests.</li>
                      <li><strong>Differences:</strong> Fetch returns promises and requires manual JSON parsing; Axios automatically parses JSON and handles errors better.</li>
                      <li><strong>Example with Fetch:</strong>
                        <pre><code>fetch('https://api.example.com/data')
              .then(res =&gt; res.json())
              .then(data =&gt; console.log(data));</code></pre>
                      </li>
                      <li><strong>Example with Axios:</strong>
                        <pre><code>import axios from 'axios';
            
            axios.get('https://api.example.com/data')
              .then(response =&gt; console.log(response.data));</code></pre>
                      </li>
                    </ul>
                  </div>
                </div>
              </div>
            
              <!-- 2. useEffect for fetching data -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-useeffect-fetch" aria-expanded="false" aria-controls="flush-useeffect-fetch">
                    2. useEffect for fetching data
                  </button>
                </h2>
                <div id="flush-useeffect-fetch" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleDataFetching">
                  <div class="accordion-body">
                    <p>Use React’s <code>useEffect</code> hook to fetch data on component mount or when dependencies change. Place fetch logic inside <code>useEffect</code> with proper dependency array to avoid infinite loops.</p>
                    <pre><code>import { useState, useEffect } from 'react';
            
            function DataComponent() {
              const [data, setData] = useState(null);
            
              useEffect(() =&gt; {
                fetch('https://api.example.com/data')
                  .then(res =&gt; res.json())
                  .then(setData);
              }, []); // Empty array runs once on mount
            
              return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...'}&lt;/div&gt;;
            }</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 3. Loading & error states -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-loading-error" aria-expanded="false" aria-controls="flush-loading-error">
                    3. Loading &amp; error states
                  </button>
                </h2>
                <div id="flush-loading-error" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleDataFetching">
                  <div class="accordion-body">
                    <p>Track loading and error states in local state to improve user experience. Show loading indicator while data is fetching, and error message if request fails.</p>
                    <pre><code>const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);
            
            useEffect(() =&gt; {
              setLoading(true);
              fetch('https://api.example.com/data')
                .then(res =&gt; res.json())
                .then(data =&gt; {
                  setData(data);
                  setLoading(false);
                })
                .catch(err =&gt; {
                  setError(err.message);
                  setLoading(false);
                });
            }, []);</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 4. Canceling requests -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-cancel-requests" aria-expanded="false" aria-controls="flush-cancel-requests">
                    4. Canceling requests
                  </button>
                </h2>
                <div id="flush-cancel-requests" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleDataFetching">
                  <div class="accordion-body">
                    <p>Abort fetch requests to avoid memory leaks or unwanted responses, especially in unmount scenarios. Use <code>AbortController</code> to cancel requests.</p>
                    <pre><code>useEffect(() =&gt; {
              const controller = new AbortController();
            
              fetch('https://api.example.com/data', { signal: controller.signal })
                .then(res =&gt; res.json())
                .then(setData)
                .catch(err =&gt; {
                  if (err.name !== 'AbortError') console.error(err);
                });
            
              return () =&gt; controller.abort(); // Cancel on unmount
            }, []);</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 5. React Query / TanStack Query: useQuery, useMutation -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-react-query" aria-expanded="false" aria-controls="flush-react-query">
                    5. React Query / TanStack Query: useQuery, useMutation
                  </button>
                </h2>
                <div id="flush-react-query" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleDataFetching">
                  <div class="accordion-body">
                    <p>React Query manages server state: fetching, caching, updating. <code>useQuery</code> for fetching data; automatically handles loading, errors, and caching. <code>useMutation</code> for creating/updating/deleting data with built-in status handling.</p>
                    <pre><code>import { useQuery } from '@tanstack/react-query';
            
            function Todos() {
              const { data, error, isLoading } = useQuery(['todos'], () =&gt;
                fetch('/api/todos').then(res =&gt; res.json())
              );
            
              if (isLoading) return 'Loading...';
              if (error) return 'Error!';
            
              return &lt;ul&gt;{data.map(todo =&gt; &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;)}&lt;/ul&gt;;
            }</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 6. Caching -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-caching" aria-expanded="false" aria-controls="flush-caching">
                    6. Caching
                  </button>
                </h2>
                <div id="flush-caching" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleDataFetching">
                  <div class="accordion-body">
                    React Query caches fetched data by default to improve performance and reduce requests. Cached data is reused until stale or invalidated.
                  </div>
                </div>
              </div>
            
              <!-- 7. Automatic refetching -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-auto-refetch" aria-expanded="false" aria-controls="flush-auto-refetch">
                    7. Automatic refetching
                  </button>
                </h2>
                <div id="flush-auto-refetch" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleDataFetching">
                  <div class="accordion-body">
                    React Query supports automatic refetch on window focus, reconnect, or intervals. Keeps UI data fresh without manual refreshes.
                  </div>
                </div>
              </div>
            
            </div>
            <div class="accordion accordion-flush my-3" id="accordionFlushExamplePerformance">
              <h3>7. Performance Optimization</h3>
            
              <!-- 1. React.memo -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-react-memo" aria-expanded="false" aria-controls="flush-react-memo">
                    1. React.memo
                  </button>
                </h2>
                <div id="flush-react-memo" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExamplePerformance">
                  <div class="accordion-body">
                    <ul>
                      <li><strong>Description:</strong> Higher-order component that memoizes functional components.</li>
                      <li><strong>Purpose:</strong> Prevents re-rendering if props haven’t changed (shallow comparison).</li>
                      <li><strong>Use case:</strong> Optimizing pure components that receive the same props frequently.</li>
                      <li><strong>Example:</strong>
                        <pre><code>const MyComponent = React.memo(function MyComponent({ value }) {
              return &lt;div&gt;{value}&lt;/div&gt;;
            });</code></pre>
                      </li>
                    </ul>
                  </div>
                </div>
              </div>
            
              <!-- 2. useMemo / useCallback -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-usememo-usecallback" aria-expanded="false" aria-controls="flush-usememo-usecallback">
                    2. useMemo / useCallback
                  </button>
                </h2>
                <div id="flush-usememo-usecallback" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExamplePerformance">
                  <div class="accordion-body">
                    <p><strong>useMemo:</strong> Memoizes expensive computed values to avoid recalculating on every render.</p>
                    <p><strong>useCallback:</strong> Memoizes functions to avoid creating new function instances each render; useful to prevent unnecessary child re-renders.</p>
                    <p><strong>Examples:</strong></p>
                    <pre><code>const computedValue = useMemo(() =&gt; heavyCalculation(data), [data]);
            
            const handleClick = useCallback(() =&gt; doSomething(), [dependency]);</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 3. Avoiding unnecessary renders -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-avoid-renders" aria-expanded="false" aria-controls="flush-avoid-renders">
                    3. Avoiding unnecessary renders
                  </button>
                </h2>
                <div id="flush-avoid-renders" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExamplePerformance">
                  <div class="accordion-body">
                    <ul>
                      <li>Use <code>React.memo</code>, <code>useMemo</code>, and <code>useCallback</code> to control when components re-render.</li>
                      <li>Pass stable props and avoid anonymous functions in JSX unless memoized.</li>
                      <li>Use keys properly in lists to help React identify changed items.</li>
                    </ul>
                  </div>
                </div>
              </div>
            
              <!-- 4. Lazy loading components (React.lazy, Suspense) -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-lazy-loading" aria-expanded="false" aria-controls="flush-lazy-loading">
                    4. Lazy loading components (React.lazy, Suspense)
                  </button>
                </h2>
                <div id="flush-lazy-loading" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExamplePerformance">
                  <div class="accordion-body">
                    <p>Load components only when needed to reduce initial bundle size. Use <code>React.lazy()</code> with <code>Suspense</code> fallback for code-splitting.</p>
                    <pre><code>const LazyComponent = React.lazy(() =&gt; import('./LazyComponent'));
            
            function App() {
              return (
                &lt;Suspense fallback=&lt;div&gt;Loading...&lt;/div&gt;&gt;
                  &lt;LazyComponent /&gt;
                &lt;/Suspense&gt;
              );
            }</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 5. Code splitting -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-code-splitting" aria-expanded="false" aria-controls="flush-code-splitting">
                    5. Code splitting
                  </button>
                </h2>
                <div id="flush-code-splitting" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExamplePerformance">
                  <div class="accordion-body">
                    Break app bundles into smaller chunks loaded on demand. Usually done with dynamic <code>import()</code> or <code>React.lazy</code>. Improves initial load times, especially for large apps.
                  </div>
                </div>
              </div>
            
              <!-- 6. Virtualization (React Window, React Virtualized) -->
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-virtualization" aria-expanded="false" aria-controls="flush-virtualization">
                    6. Virtualization (React Window, React Virtualized)
                  </button>
                </h2>
                <div id="flush-virtualization" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExamplePerformance">
                  <div class="accordion-body">
                    <p>Render only visible items in large lists or tables to reduce DOM nodes and improve performance. Libraries like React Window and React Virtualized provide virtualization utilities.</p>
                    <pre><code>import { FixedSizeList as List } from 'react-window';
            
            &lt;List
              height={150}
              itemCount={1000}
              itemSize={35}
              width={300}
            &gt;
              {({ index, style }) =&gt; (
                &lt;div style={style}&gt;Row {index}&lt;/div&gt;
              )}
            &lt;/List&gt;</code></pre>
                  </div>
                </div>
              </div>
            
            </div>
            <div class="accordion accordion-flush my-3" id="accordionFlushExampleAdvancedReact">
              <h3>8. Advanced React Concepts</h3>
            
              <!-- 1. Reconciliation & Virtual DOM -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-reconciliation">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-reconciliation" aria-expanded="false" aria-controls="flush-reconciliation">
                    1. Reconciliation &amp; Virtual DOM
                  </button>
                </h2>
                <div id="flush-reconciliation" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleAdvancedReact">
                  <div class="accordion-body">
                    <ul>
                      <li>React keeps a lightweight copy of the DOM called the Virtual DOM.</li>
                      <li>On state or props changes, React compares the new Virtual DOM with the previous one (diffing algorithm).</li>
                      <li>Only updates the real DOM where differences exist, optimizing performance.</li>
                    </ul>
                  </div>
                </div>
              </div>
            
              <!-- 2. Fiber architecture basics -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-fiber">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-fiber" aria-expanded="false" aria-controls="flush-fiber">
                    2. Fiber architecture basics
                  </button>
                </h2>
                <div id="flush-fiber" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleAdvancedReact">
                  <div class="accordion-body">
                    <ul>
                      <li>Fiber is React’s reimplementation of the reconciliation algorithm.</li>
                      <li>Enables interruptible rendering and prioritizes updates for smoother UI.</li>
                      <li>Breaks rendering work into chunks to avoid blocking the main thread.</li>
                    </ul>
                  </div>
                </div>
              </div>
            
              <!-- 3. Strict Mode -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-strictmode">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-strictmode" aria-expanded="false" aria-controls="flush-strictmode">
                    3. Strict Mode
                  </button>
                </h2>
                <div id="flush-strictmode" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleAdvancedReact">
                  <div class="accordion-body">
                    <p><code>&lt;React.StrictMode&gt;</code> is a tool for highlighting potential problems in an app during development.</p>
                    <ul>
                      <li>Checks for unsafe lifecycle methods, legacy API usage, and side effects.</li>
                      <li>Does not affect production build.</li>
                    </ul>
                  </div>
                </div>
              </div>
            
              <!-- 4. Error boundaries -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-errorboundaries">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-errorboundaries" aria-expanded="false" aria-controls="flush-errorboundaries">
                    4. Error boundaries
                  </button>
                </h2>
                <div id="flush-errorboundaries" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleAdvancedReact">
                  <div class="accordion-body">
                    <p>React components that catch JavaScript errors in their child component tree, prevent entire app from crashing and display fallback UI.</p>
                    <p>Implemented using lifecycle method <code>componentDidCatch</code> or static <code>getDerivedStateFromError</code>.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>class ErrorBoundary extends React.Component {
              state = { hasError: false };
            
              static getDerivedStateFromError() {
                return { hasError: true };
              }
            
              componentDidCatch(error, info) {
                console.error(error, info);
              }
            
              render() {
                if (this.state.hasError) return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;
                return this.props.children;
              }
            }</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 5. Portals -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-portals">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-portals" aria-expanded="false" aria-controls="flush-portals">
                    5. Portals
                  </button>
                </h2>
                <div id="flush-portals" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleAdvancedReact">
                  <div class="accordion-body">
                    <p>Render children into a DOM node outside the parent component hierarchy. Useful for modals, tooltips, or overlays that require different stacking context.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>ReactDOM.createPortal(&lt;Modal /&gt;, document.getElementById('modal-root'));</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 6. Forwarding refs (forwardRef) -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-forwardingrefs">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-forwardingrefs" aria-expanded="false" aria-controls="flush-forwardingrefs">
                    6. Forwarding refs (forwardRef)
                  </button>
                </h2>
                <div id="flush-forwardingrefs" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleAdvancedReact">
                  <div class="accordion-body">
                    <p>Allows passing refs through components to access DOM nodes or child components.</p>
                    <p>Useful when you want parent components to control child DOM elements.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>const FancyInput = React.forwardRef((props, ref) =&gt; (
              &lt;input ref={ref} {...props} /&gt;
            ));</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 7. Render props -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-renderprops">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-renderprops" aria-expanded="false" aria-controls="flush-renderprops">
                    7. Render props
                  </button>
                </h2>
                <div id="flush-renderprops" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleAdvancedReact">
                  <div class="accordion-body">
                    <p>Technique where a component’s child is a function that returns React elements. Enables sharing code between components using a function as a child.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>&lt;DataFetcher render={data =&gt; &lt;div&gt;{data}&lt;/div&gt;} /&gt;</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 8. Higher-order components (HOCs) -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-hocs">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-hocs" aria-expanded="false" aria-controls="flush-hocs">
                    8. Higher-order components (HOCs)
                  </button>
                </h2>
                <div id="flush-hocs" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleAdvancedReact">
                  <div class="accordion-body">
                    <p>Functions that take a component and return an enhanced component. Used for reusing component logic (e.g., authentication, logging).</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>function withLogger(WrappedComponent) {
              return function(props) {
                console.log('Rendering', WrappedComponent.name);
                return &lt;WrappedComponent {...props} /&gt;;
              };
            }</code></pre>
                  </div>
                </div>
              </div>
            
            </div>
            <div class="accordion accordion-flush my-3" id="accordionFlushExampleStylingReact">
              <h3>9. Styling in React</h3>
            
              <!-- 1. CSS Modules -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-cssmodules">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-cssmodules" aria-expanded="false" aria-controls="flush-cssmodules">
                    1. CSS Modules
                  </button>
                </h2>
                <div id="flush-cssmodules" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleStylingReact">
                  <div class="accordion-body">
                    <p>CSS files scoped locally by default, avoiding class name conflicts.</p>
                    <p>Import styles as objects and use them in JSX.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>import styles from './Button.module.css';
            
            function Button() {
              return &lt;button className={styles.primary}&gt;Click me&lt;/button&gt;;
            }</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 2. Styled-components / Emotion -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-styledcomponents">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-styledcomponents" aria-expanded="false" aria-controls="flush-styledcomponents">
                    2. Styled-components / Emotion
                  </button>
                </h2>
                <div id="flush-styledcomponents" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleStylingReact">
                  <div class="accordion-body">
                    <p>CSS-in-JS libraries allowing styling via JavaScript.</p>
                    <p>Define styled components with tagged template literals.</p>
                    <p>Supports dynamic styling with props.</p>
                    <p><strong>Example (styled-components):</strong></p>
                    <pre><code>import styled from 'styled-components';
            
            const Button = styled.button`
              background: blue;
              color: white;
              padding: 10px;
            `;
            
            function App() {
              return &lt;Button&gt;Click me&lt;/Button&gt;;
            }</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 3. Tailwind CSS -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-tailwindcss">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-tailwindcss" aria-expanded="false" aria-controls="flush-tailwindcss">
                    3. Tailwind CSS
                  </button>
                </h2>
                <div id="flush-tailwindcss" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleStylingReact">
                  <div class="accordion-body">
                    <p>Utility-first CSS framework providing predefined classes.</p>
                    <p>Enables fast styling directly in JSX with <code>className</code> attributes.</p>
                    <p>Encourages consistency and responsive design.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>function Button() {
              return &lt;button className="bg-blue-500 text-white p-2 rounded"&gt;Click me&lt;/button&gt;;
            }</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 4. Inline styles -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-inlinestyles">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-inlinestyles" aria-expanded="false" aria-controls="flush-inlinestyles">
                    4. Inline styles
                  </button>
                </h2>
                <div id="flush-inlinestyles" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleStylingReact">
                  <div class="accordion-body">
                    <p>Styles defined directly on JSX elements as objects.</p>
                    <p>Useful for dynamic or one-off styles but lacks pseudo-classes and media queries.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>function Button() {
              return &lt;button style={{ backgroundColor: 'blue', color: 'white', padding: '10px' }}&gt;Click me&lt;/button&gt;;
            }</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 5. Ant Design / Material UI components -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-antdesignmui">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-antdesignmui" aria-expanded="false" aria-controls="flush-antdesignmui">
                    5. Ant Design / Material UI components
                  </button>
                </h2>
                <div id="flush-antdesignmui" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleStylingReact">
                  <div class="accordion-body">
                    <p>Popular React UI component libraries with pre-built, customizable components.</p>
                    <p>Provide consistent design, theming, and accessibility features.</p>
                    <p><strong>Example (Material UI):</strong></p>
                    <pre><code>import Button from '@mui/material/Button';
            
            function App() {
              return &lt;Button variant="contained" color="primary"&gt;Click me&lt;/Button&gt;;
            }</code></pre>
                  </div>
                </div>
              </div>
            </div>
            <div class="accordion accordion-flush my-3" id="accordionFlushExampleTestingReact">
              <h3>10. Testing in React</h3>
            
              <!-- 1. Unit testing with Jest -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-jest">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-jest" aria-expanded="false" aria-controls="flush-jest">
                    1. Unit testing with Jest
                  </button>
                </h2>
                <div id="flush-jest" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleTestingReact">
                  <div class="accordion-body">
                    <p>Jest is the default testing framework for React apps.</p>
                    <p>Tests individual functions or components in isolation.</p>
                    <p>Supports mocks, timers, and snapshot testing.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>test('adds 1 + 2 to equal 3', () => {
              expect(1 + 2).toBe(3);
            });</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 2. Component testing with React Testing Library -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-testinglibrary">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-testinglibrary" aria-expanded="false" aria-controls="flush-testinglibrary">
                    2. Component testing with React Testing Library
                  </button>
                </h2>
                <div id="flush-testinglibrary" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleTestingReact">
                  <div class="accordion-body">
                    <p>Focuses on testing components as users interact with them.</p>
                    <p>Encourages testing behavior over implementation details.</p>
                    <p>Provides utilities to query and interact with rendered components.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>import { render, screen, fireEvent } from '@testing-library/react';
            import Button from './Button';
            
            test('renders button and responds to click', () => {
              const handleClick = jest.fn();
              render(&lt;Button onClick={handleClick}&gt;Click me&lt;/Button&gt;);
              fireEvent.click(screen.getByText(/click me/i));
              expect(handleClick).toHaveBeenCalledTimes(1);
            });</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 3. Snapshot testing -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-snapshot">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-snapshot" aria-expanded="false" aria-controls="flush-snapshot">
                    3. Snapshot testing
                  </button>
                </h2>
                <div id="flush-snapshot" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleTestingReact">
                  <div class="accordion-body">
                    <p>Captures a “snapshot” of a component’s rendered output.</p>
                    <p>Alerts when UI changes unexpectedly.</p>
                    <p>Useful for regression testing UI components.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>import renderer from 'react-test-renderer';
            import Button from './Button';
            
            test('renders correctly', () => {
              const tree = renderer.create(&lt;Button&gt;Click me&lt;/Button&gt;).toJSON();
              expect(tree).toMatchSnapshot();
            });</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 4. Mocking APIs -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-mockingapis">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-mockingapis" aria-expanded="false" aria-controls="flush-mockingapis">
                    4. Mocking APIs
                  </button>
                </h2>
                <div id="flush-mockingapis" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleTestingReact">
                  <div class="accordion-body">
                    <p>Simulate backend responses to isolate frontend tests.</p>
                    <p>Jest provides <code>jest.mock()</code> for mocking modules or API calls.</p>
                    <p>Tools like MSW (Mock Service Worker) mock network requests in tests.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>jest.mock('./api');
            import { fetchData } from './api';
            
            fetchData.mockResolvedValue({ data: 'mocked data' });</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 5. E2E testing (Cypress, Playwright) -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-e2e">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-e2e" aria-expanded="false" aria-controls="flush-e2e">
                    5. E2E testing (Cypress, Playwright)
                  </button>
                </h2>
                <div id="flush-e2e" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleTestingReact">
                  <div class="accordion-body">
                    <p>Tests the full user flow in a real browser environment.</p>
                    <p>Validates integration of frontend with backend.</p>
                    <p>Cypress and Playwright offer powerful APIs for interaction and assertions.</p>
                    <p><strong>Example (Cypress):</strong></p>
                    <pre><code>describe('Login flow', () => {
              it('logs in successfully', () => {
                cy.visit('/login');
                cy.get('input[name="username"]').type('user');
                cy.get('input[name="password"]').type('password');
                cy.get('button[type="submit"]').click();
                cy.url().should('include', '/dashboard');
              });
            });</code></pre>
                  </div>
                </div>
              </div>
            
            </div>
            <div class="accordion accordion-flush my-3" id="accordionFlushExampleReactTS">
              <h3>11. React with TypeScript</h3>
            
              <!-- 1. Typing props & state -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-typing-props-state">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-typing-props-state" aria-expanded="false" aria-controls="flush-typing-props-state">
                    1. Typing props & state
                  </button>
                </h2>
                <div id="flush-typing-props-state" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleReactTS">
                  <div class="accordion-body">
                    <p>Define interfaces or types for component props and state to get type safety.</p>
                    <p>Helps catch errors early and improves code readability.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>interface ButtonProps {
              label: string;
              onClick: () =&gt; void;
            }
            
            function Button({ label, onClick }: ButtonProps) {
              return &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;;
            }</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 2. React.FC vs function components -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-react-fc-vs-fn">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-react-fc-vs-fn" aria-expanded="false" aria-controls="flush-react-fc-vs-fn">
                    2. React.FC vs function components
                  </button>
                </h2>
                <div id="flush-react-fc-vs-fn" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleReactTS">
                  <div class="accordion-body">
                    <p>React.FC (FunctionComponent) is a TypeScript type for functional components.</p>
                    <p>It automatically types <code>children</code> prop but has some limitations (e.g., default props).</p>
                    <p>Many prefer plain functions with explicit typing for more control.</p>
                    <p><strong>Example with React.FC:</strong></p>
                    <pre><code>const Button: React.FC&lt;ButtonProps&gt; = ({ label, children }) =&gt; (
              &lt;button&gt;{label} {children}&lt;/button&gt;
            );</code></pre>
                    <p><strong>Example without React.FC:</strong></p>
                    <pre><code>function Button({ label }: ButtonProps) {
              return &lt;button&gt;{label}&lt;/button&gt;;
            }</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 3. Generics with components -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-generics-components">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-generics-components" aria-expanded="false" aria-controls="flush-generics-components">
                    3. Generics with components
                  </button>
                </h2>
                <div id="flush-generics-components" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleReactTS">
                  <div class="accordion-body">
                    <p>Use generics to create reusable components that work with different data types.</p>
                    <p>Enables strong typing while keeping flexibility.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>interface ListProps&lt;T&gt; {
              items: T[];
              renderItem: (item: T) =&gt; React.ReactNode;
            }
            
            function List&lt;T&gt;({ items, renderItem }: ListProps&lt;T&gt;) {
              return &lt;ul&gt;{items.map(renderItem)}&lt;/ul&gt;;
            }</code></pre>
                  </div>
                </div>
              </div>
            
              <!-- 4. Typing hooks -->
              <div class="accordion-item">
                <h2 class="accordion-header" id="heading-typing-hooks">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-typing-hooks" aria-expanded="false" aria-controls="flush-typing-hooks">
                    4. Typing hooks
                  </button>
                </h2>
                <div id="flush-typing-hooks" class="accordion-collapse collapse" data-bs-parent="#accordionFlushExampleReactTS">
                  <div class="accordion-body">
                    <p>Type React hooks to enforce correct usage and improve autocompletion.</p>
                    <p>For useState, specify the state type explicitly if not inferred.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>const [count, setCount] = useState&lt;number&gt;(0);
            
            const inputRef = useRef&lt;HTMLInputElement&gt;(null);</code></pre>
                  </div>
                </div>
              </div>
            
            </div>
            
            
                     
          
            
          </div>
      </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js" integrity="sha384-ndDqU0Gzau9qJ1lfW4pNLlhNTkCfHzAVBReH9diLvGRem5+R9g2FzA8ZGN954O5Q" crossorigin="anonymous"></script>
    <script src="main.js"></script>
</body>
</html>